import operator

# Each die face is a tuple with four numbers representing results on that face.
# - The four numbers represent: (Success/Failure, Advantage/Threat, Triumph, Despair).
# - Success and Advantage are positive integers, while Failure and Threat are negative integers.
# - Triumph and Despair are each either 0 or 1 (for counting purposes).
# Each die type is a dictionary: boost, setback, ability, difficulty, proficiency, challenge.
# - The keys are die faces (as described above)
# - The values are the number of times each die face appears on the die type.

boost = {(0, 0, 0, 0): 2,
         (1, 0, 0, 0): 1,
         (1, 1, 0, 0): 1,
         (0, 1, 0, 0): 1,
         (0, 2, 0, 0): 1}

setback = {(0, 0, 0, 0): 2,
           (-1, 0, 0, 0): 2,
           (0, -1, 0, 0): 2}

ability = {(0, 0, 0, 0): 1,
           (1, 0, 0, 0): 2,
           (2, 0, 0, 0): 1,
           (0, 1, 0, 0): 2,
           (1, 1, 0, 0): 1,
           (0, 2, 0, 0): 1}

difficulty = {(0, 0, 0, 0): 1,
              (-1, 0, 0, 0): 1,
              (-2, 0, 0, 0): 1,
              (0, -1, 0, 0): 3,
              (0, -2, 0, 0): 1,
              (-1, -1, 0, 0): 1}

proficiency = {(0, 0, 0, 0): 1,
               (1, 0, 0, 0): 2,
               (2, 0, 0, 0): 2,
               (0, 1, 0, 0): 1,
               (1, 1, 0, 0): 3,
               (0, 2, 0, 0): 2,
               (1, 0, 1, 0): 1}

challenge = {(0, 0, 0, 0): 1,
             (-1, 0, 0, 0): 2,
             (-2, 0, 0, 0): 2,
             (0, -1, 0, 0): 2,
             (-1, -1, 0, 0): 2,
             (0, -2, 0, 0): 2,
             (-1, 0, 0, 1): 1}


# Functions to access result types in a die face tuple by name
def success(result): return result[0]  # A negative result here means some number of Failures.
def advantage(result): return result[1]  # A negative result here means some number of Threats.
def triumph(result): return result[2]
def despair(result): return result[3]


class DicePoolReporter:
    # Takes dice list (see variables above) and immediately counts all possible outcomes from rolling those dice.
    # Outcomes are stored in a dict with 4-tuples as keys and outcome counts as values. Each tuple is a possible outcome
    # and each integer count is the number of ways that outcome can be rolled. The 4-tuples represent the summed results
    # of the specific outcome (success/failure, advantage/threat, triumph, and despair).

    def __init__(self, dice_pool_list, significant_digits):
        self.sig_digits = significant_digits
        self.dice_pool = dice_pool_list
        self.outcomes = {}  # A dict of outcome counts keyed by 4-tuple outcomes
        self.s_counts = {}  # Collapsed dict of success/failure outcome counts keyed by number of success/failure
        self.a_counts = {}  # Collapsed dict or advantage/threat outcome counts keyed by number of advantage/threat
        self.t_counts = {}  # Collapsed dict of triumph outcome counts keyed by number of triumphs
        self.d_counts = {}  # Collapsed dict of despair outcome counts keyed by number of despairs
        self.count_equivalent_outcomes(dice_pool_list)
        self.count_equivalent_outcomes_per_result()
        self.total_results = float(sum(self.outcomes.values()))  # Cast to float for later division
        self.s_discrete = self.calculate_result_discrete(self.s_counts)
        self.a_discrete = self.calculate_result_discrete(self.a_counts)
        self.s_cumulative = self.calculate_result_cumulative(self.s_counts)
        self.a_cumulative = self.calculate_result_cumulative(self.a_counts)

    def count_equivalent_outcomes(self, dice_list):
        # Count occurrences of equivalent outcomes (identical 4-tuples generated by different dice rolls)
        outcomes = dice_list[0]
        for die in dice_list[1:]:
            next_outcomes = {}
            for outcome, outcome_count in outcomes.items():
                for face, face_count in die.items():
                    outcome_sum = tuple(map(operator.add, outcome, face))
                    next_outcomes[outcome_sum] = next_outcomes.get(outcome_sum, 0) + (outcome_count * face_count)
            outcomes = next_outcomes
        self.outcomes = outcomes

    def count_equivalent_outcomes_per_result(self):
        for outcome, count in self.outcomes.items():
            self.s_counts[success(outcome)] = self.s_counts.get(success(outcome), 0) + count
            self.a_counts[advantage(outcome)] = self.a_counts.get(advantage(outcome), 0) + count
            self.t_counts[triumph(outcome)] = self.t_counts.get(triumph(outcome), 0) + count
            self.d_counts[despair(outcome)] = self.d_counts.get(despair(outcome), 0) + count

    def to_percent(self, count): return round((count / self.total_results * 100), self.sig_digits)

    def calculate_result_discrete(self, result_counts):
        discrete_results = {}
        for results, count in sorted(result_counts.items(), reverse=True):
            discrete_results[results] = discrete_results.get(results, 0) + self.to_percent(count)
        return discrete_results.copy()

    def calculate_result_cumulative(self, result_counts):
        cumulative_results = {}
        positive = 0.0
        negative = 0.0
        for results, count in sorted(result_counts.items(), reverse=True):
            if results > 0:
                positive += self.to_percent(count)
                cumulative_results[results] = cumulative_results.get(results, 0) + positive
            else:
                break
        for results, count in sorted(result_counts.items()):
            if results <= 0:
                negative += self.to_percent(count)
                cumulative_results[results] = cumulative_results.get(results, 0) + negative
            else:
                break
        return cumulative_results.copy()

    def calculate_expected_value(self, result_counts):
        ev = 0
        for results, count in result_counts.items():
            ev += results * (count / self.total_results)
        return ev
